=== File: a1.py ===
import os

output_file = "merged_prompt.txt"

def append_file_content(output_path):
    with open(output_path, 'w', encoding='utf-8') as output:
        for file_name in os.listdir('.'):
            if os.path.isfile(file_name):
                try:
                    with open(file_name, 'r', encoding='utf-8') as file:
                        content = file.read()
                
                    output.write(f"=== File: {file_name} ===\n")
                    output.write(content)
                    output.write("\n\n")
                except Exception as e:
                    print(f"Could not read file {file_name}: {e}")
    print(f"All file contents have been merged into '{output_path}'")

append_file_content(output_file)


=== File: aes_ecb_mode.py ===
#aes_ecb_mode.py
from Crypto.Cipher import AES

key = b'16bytekey1234567'
cipher = AES.new(key, AES.MODE_ECB)
encrypted = cipher.encrypt(b'16byteblock12345')
print("AES ECB Encrypted:", encrypted)


=== File: argon2_password.py ===
#argon2_password.py
from argon2 import PasswordHasher

ph = PasswordHasher()
hash = ph.hash("securepassword")
print("Argon2 Hash:", hash)


=== File: bcrypt_password.py ===
#bcrypt_password.py
import bcrypt

password = b"securepassword"
hashed = bcrypt.hashpw(password, bcrypt.gensalt())
print("bcrypt Hash:", hashed)


=== File: cbc_static_iv.py ===
#cbc_static_iv.py
from Crypto.Cipher import AES

key = b'16bytekey1234567'
iv = b'staticIV12345678'  # Static IV is insecure
cipher = AES.new(key, AES.MODE_CBC, iv)
encrypted = cipher.encrypt(b'16byteblock12345')
print("AES CBC Encrypted with Static IV:", encrypted)


=== File: deprecated_protocols_usage.py ===
#deprecated_protocols_usage.py
import ssl

# Deprecated protocol usage
context = ssl.SSLContext(ssl.PROTOCOL_SSLv3)  # SSLv3 is insecure and deprecated
print("SSL Context with SSLv3 created:", context)


=== File: dh_vulnerable_params.py ===
#dh_vulnerable_params.py
from cryptography.hazmat.primitives.asymmetric import dh

# Using weak parameters for Diffie-Hellman
parameters = dh.generate_parameters(generator=1, key_size=1024)  # Weak generator and key size
private_key = parameters.generate_private_key()
print("Weak Diffie-Hellman Private Key:", private_key)


=== File: diffie_hellman.py ===
#diffie_hellman.py
from cryptography.hazmat.primitives.asymmetric import dh

parameters = dh.generate_parameters(generator=2, key_size=2048)
private_key = parameters.generate_private_key()
print("Diffie-Hellman Private Key:", private_key)


=== File: ecc_deprecated_curve.py ===
#ecc_deprecated_curve.py
from cryptography.hazmat.primitives.asymmetric import ec

# Using a deprecated or insecure curve (non-recommended)
private_key = ec.generate_private_key(ec.SECP192R1())
public_key = private_key.public_key()
print("ECC Public Key with Deprecated Curve:", public_key)


=== File: ecc_key_generation.py ===
#ecc_key_generation.py
from cryptography.hazmat.primitives.asymmetric import ec

private_key = ec.generate_private_key(ec.SECP256R1())
public_key = private_key.public_key()
print("ECC Public Key:", public_key)


=== File: hardcoded_credentials.py ===
#hardcoded_credentials.py
# Example of hardcoded credentials
USERNAME = "admin"
PASSWORD = "supersecretpassword123"  # This should be securely stored, not hardcoded


=== File: hmac_with_md5_sha1.py ===
#hmac_with_md5_sha1.py
import hmac
import hashlib

key = b"secret_key"
message = b"important_message"

# Using MD5 and SHA-1 in HMAC (deprecated)
hmac_md5 = hmac.new(key, message, hashlib.md5).hexdigest()
hmac_sha1 = hmac.new(key, message, hashlib.sha1).hexdigest()

print("HMAC MD5:", hmac_md5)
print("HMAC SHA-1:", hmac_sha1)


=== File: insecure_des_usage.py ===
#insecure_des_usage.py
from Crypto.Cipher import DES

key = b'8bytekey'
cipher = DES.new(key, DES.MODE_ECB)
encrypted = cipher.encrypt(b'secret12')


=== File: insecure_random_key.py ===
#insecure_random_key.py
import random

# Using random for key generation (not cryptographically secure)
key = "".join(random.choice("abcdefghijklmnopqrstuvwxyz0123456789") for _ in range(16))
print("Insecure Random Key:", key)


=== File: insecure_sha1.py ===
#insecure_sha1.py
import hashlib

data = b"important data"
hashed = hashlib.sha1(data).hexdigest()
print("SHA-1 Hash:", hashed)


=== File: md5_collision_example.py ===
#md5_collision_example.py
import hashlib

# Two different inputs that produce the same MD5 hash (collision example)
data1 = b"Example1"
data2 = b"Example2"
hash1 = hashlib.md5(data1).hexdigest()
hash2 = hashlib.md5(data2).hexdigest()

print("Hash 1:", hash1)
print("Hash 2:", hash2)
print("Collision Detected:", hash1 == hash2)


=== File: merged_prompt.txt ===


=== File: misuse_of_crypto_library.py ===
#misuse_of_crypto_library.py
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.hashes import SHA256
from cryptography.hazmat.backends import default_backend

key_material = b"key_material"

# Incorrectly reusing the same key material without proper diversification
hkdf = HKDF(algorithm=SHA256(), length=32, salt=None, info=None, backend=default_backend())
key1 = hkdf.derive(key_material)
key2 = hkdf.derive(key_material)  # Reuse of the same key material
print("Derived Keys:", key1, key2)


=== File: no_certificate_validation.py ===
#no_certificate_validation.py
import ssl
import socket

# Example of missing certificate validation
hostname = 'example.com'
context = ssl._create_unverified_context()  # Insecure: skips certificate validation

with socket.create_connection((hostname, 443)) as sock:
    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
        print("Established insecure connection to:", ssock.getpeercert())


=== File: outdated_md5_hash.py ===
#outdated_md5_hash.py
import hashlib

data = b"password123"
hashed = hashlib.md5(data).hexdigest()
print("MD5 Hash:", hashed)


=== File: password_hashing_no_salt.py ===
#password_hashing_no_salt.py
import hashlib

# Hashing without salt
password = b"securepassword"
hashed_password = hashlib.sha256(password).hexdigest()
print("Password Hash without Salt:", hashed_password)


=== File: rsa_no_padding.py ===
#rsa_no_padding.py
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5

key = RSA.generate(2048)
cipher = PKCS1_v1_5.new(key)  # RSA without padding is insecure
plaintext = b"Sensitive data"
ciphertext = cipher.encrypt(plaintext)
print("RSA Encrypted without Padding:", ciphertext)


=== File: secure_aes_gcm.py ===
#secure_aes_gcm.py
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

key = get_random_bytes(16)
cipher = AES.new(key, AES.MODE_GCM)
ciphertext, tag = cipher.encrypt_and_digest(b"secure message")
print("AES GCM Encrypted:", ciphertext)


=== File: test_aes_weak_modes.py ===
#test_aes_weak_modes.py
from Crypto.Cipher import AES

# AES in ECB mode (insecure mode)
key = b'sixteen byte key'
cipher = AES.new(key, AES.MODE_ECB)


=== File: test_embedded_protocols.py ===
#test_embedded_protocols.py
# Simulate hardcoded outdated protocol references
protocols = ["TLSv1.0", "SSLv3", "IKEv1"]

for protocol in protocols:
    print(f"Using protocol: {protocol}")


=== File: test_hardcoded_keys.py ===
#test_hardcoded_keys.py
# Hardcoded symmetric key
secret_key = "aabbccddeeff00112233445566778899"  # Hex-encoded key

# Hardcoded RSA private key
private_key_pem = """
-----BEGIN RSA PRIVATE KEY-----
MIIBOgIBAAJBALq+idRfN9DJHVrv+Q39EJuw+jr8AWF7Q52XTYdx01/Bsw==
-----END RSA PRIVATE KEY-----
"""


=== File: test_hash_algorithms.py ===
#test_hash_algorithms.py
import hashlib

# SHA-1 (deprecated)
hash1 = hashlib.sha1(b"data").hexdigest()

# SHA-224 (deprecated variant of SHA-2)
hash224 = hashlib.sha224(b"data").hexdigest()


=== File: test_hybrid_crypto.py ===
#test_hybrid_crypto.py
from cryptography.hazmat.primitives.asymmetric import rsa
from pqcrypto.kem.kyber import generate_keypair, encapsulate

# Hybrid RSA and Kyber
rsa_private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048  # Secure RSA key size
)

# Kyber Key Encapsulation
kyber_pubkey, kyber_privkey = generate_keypair()
shared_secret, encapsulation = encapsulate(kyber_pubkey)


=== File: test_outdated_protocols.py ===
#test_outdated_protocols.py
import ssl
import paramiko

# Deprecated SSL/TLS protocol
context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)  # Deprecated protocol version

# Deprecated SSH key type
key = paramiko.DSSKey()  # Deprecated SSH DSA key


=== File: test_weak_key_sizes.py ===
#test_weak_key_sizes.py
from cryptography.hazmat.primitives.asymmetric import rsa, ec

# Weak RSA Key
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=1024  # Weak key size
)

# ECDH Key Exchange
ec_key = ec.generate_private_key(
    ec.SECP192R1()  # Non-recommended curve
)


=== File: tls_outdated_cipher_suite.py ===
#tls_outdated_cipher_suite.py
import ssl

# Using an outdated cipher suite in TLS
context = ssl.create_default_context()
context.set_ciphers("DES-CBC3-SHA")  # Weak cipher suite
print("TLS Context with Weak Cipher Suite:", context)


=== File: weak_pbkdf2.py ===
#weak_pbkdf2.py
from hashlib import pbkdf2_hmac

password = b"weak_password"
salt = b"random_salt"
iterations = 1000  # Insufficient iterations

key = pbkdf2_hmac('sha256', password, salt, iterations)
print("Derived Key with Weak PBKDF2:", key)


=== File: weak_prng.py ===
#weak_prng.py
import random

# Using a weak PRNG for cryptographic purposes
key = random.randint(1, 1000000)
print("Weak PRNG Key:", key)


=== File: weak_rsa_key.py ===
#weak_rsa_key.py
from Crypto.PublicKey import RSA

key = RSA.generate(1024)
print("Weak RSA Key:", key.export_key().decode())


